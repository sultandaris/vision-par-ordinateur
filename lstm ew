import kagglehub

# Download latest version
path = kagglehub.dataset_download("diraizel/anime-images-dataset")

print("Path to dataset files:", path)
import os
import cv2
# files = os.listdir(path)
# madeinabbys = os.path.join(path, "data" , "anime_images", "Made in Abyss")
# print("Files in dataset directory:", os.listdir(madeinabbys))

# for img in os.listdir(madeinabbys)[:15]:
#     img_path = os.path.join(madeinabbys, img)
#     print("Image path:", img_path)
#     cv2_img = cv2.imread(img_path)
#     resized_img = cv2.resize(cv2_img, (128, 128))
#     cv2.imshow("Anime Image", resized_img)
#     cv2.waitKey(0)
#     cv2.destroyAllWindows() 

# mononoke = os.path.join(path, "data" , "anime_images", "Mononoke")
# print("Files in dataset directory:", os.listdir(mononoke))

# for img in os.listdir(mononoke)[:15]:
#     img_path = os.path.join(mononoke, img)
#     print("Image path:", img_path)
#     cv2_img = cv2.imread(img_path)
#     resized_img = cv2.resize(cv2_img, (128, 128))
#     cv2.imshow("Anime Image", resized_img)
#     cv2.waitKey(0)
#     cv2.destroyAllWindows() 
    
#lstm for anime from my 2 label , madeinabbys and mononoke
import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Flatten
from tensorflow.keras.preprocessing.image import img_to_array, load_img
from sklearn.model_selection import train_test_split    
from sklearn.preprocessing import LabelBinarizer
from sklearn.metrics import confusion_matrix, roc_curve, auc, precision_recall_curve, classification_report, ConfusionMatrixDisplay
data = []
labels = []
for category in ["Made in Abyss", "Mononoke"]:
    folder_path = os.path.join(path, "data" , "anime_images", category)
    for img in os.listdir(folder_path):
        img_path = os.path.join(folder_path, img)
        cv2_img = cv2.imread(img_path)
        resized_img = cv2.resize(cv2_img, (128, 128))
        data.append(img_to_array(resized_img))
        labels.append(category)

data = np.array(data)
labels = np.array(labels)
labels = LabelBinarizer().fit_transform(labels)

# Normalize data
data = data.astype("float") / 255.0
print(data)
print(labels)
# train, validate, test split

X_train, X_temp, y_train, y_temp = train_test_split(data, labels, test_size=0.3, random_state=42)
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42)
print("Train shape:", X_train.shape, y_train.shape)
print("Validation shape:", X_val.shape, y_val.shape)
print("Test shape:", X_test.shape, y_test.shape)

# Build LSTM model
model = Sequential()
model.add(LSTM(64, input_shape=(128, 128*3), return_sequences=True))
model.add(Flatten())
model.add(Dense(32, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.summary()

# Reshape data for LSTM
X_train_reshaped = X_train.reshape((X_train.shape[0], 128, 128*3))
X_val_reshaped = X_val.reshape((X_val.shape[0], 128, 128*3))
X_test_reshaped = X_test.reshape((X_test.shape[0], 128, 128*3))

# Train model
model.fit(X_train_reshaped, y_train, validation_data=(X_val_reshaped, y_val), epochs=30, batch_size=32)

# Evaluate model
loss, accuracy = model.evaluate(X_test_reshaped, y_test)
print(f"Test Loss: {loss}, Test Accuracy: {accuracy}")

# show me some test images with predicted labels
predictions = model.predict(X_test_reshaped)
for i in range(5):
    img = X_test[i]
    pred_label = "Made in Abyss" if predictions[i] > 0.5 else "Mononoke"
    cv2.imshow(f"Predicted: {pred_label}", img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    #give me graph of training and validation accuracy and loss plus confusion matrix and AUC curves
    import matplotlib.pyplot as plt

    # original training/validation plots
    history = model.history
    plt.figure(figsize=(12, 4))
    plt.subplot(1, 2, 1)
    plt.plot(history.history['accuracy'], label='Train Accuracy')
    plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
    plt.title('Accuracy')
    plt.xlabel('Epochs')
    plt.ylabel('Accuracy')
    plt.legend()
    plt.subplot(1, 2, 2)
    plt.plot(history.history['loss'], label='Train Loss')
    plt.plot(history.history['val_loss'], label='Validation Loss')
    plt.title('Loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()
    plt.show()

    # prepare predicted probabilities and labels
    y_true = y_test.ravel()
    y_prob = predictions.ravel()
    y_pred = (y_prob > 0.5).astype(int)

    # confusion matrix
    cm = confusion_matrix(y_true, y_pred)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=["Mononoke", "Made in Abyss"])
    plt.figure(figsize=(6, 5))
    disp.plot(cmap=plt.cm.Blues, values_format='d', ax=plt.gca())
    plt.title("Confusion Matrix")
    plt.show()

    # classification report
    print("Classification report:")
    print(classification_report(y_true, y_pred, target_names=["Mononoke", "Made in Abyss"]))

    # ROC and Precision-Recall curves with AUCs
    fpr, tpr, _ = roc_curve(y_true, y_prob)
    roc_auc = auc(fpr, tpr)
    rec, prec, _ = precision_recall_curve(y_true, y_prob)
    pr_auc = auc(rec, prec)

    plt.figure(figsize=(12, 5))
    plt.subplot(1, 2, 1)
    plt.plot(fpr, tpr, label=f'ROC (AUC = {roc_auc:.3f})')
    plt.plot([0, 1], [0, 1], 'k--', alpha=0.5)
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('ROC Curve')
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(rec, prec, label=f'PR (AUC = {pr_auc:.3f})')
    plt.xlabel('Recall')
    plt.ylabel('Precision')
    plt.title('Precision-Recall Curve')
    plt.legend()
    plt.show()

